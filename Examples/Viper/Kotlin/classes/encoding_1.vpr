/***

// The @Pure annotation is similar to what Prusti does, it assumes it is a pure
// mathematical function.

open class A(val foo: Int, val bar: Int) {
    @Pure fun sum(): Int = foo + bar
}

// In this case the class B does not ovveride the `foo` and `bar`
class B(val zig: Int, foo: Int, bar: Int): A(foo, bar) 

// Class hierarchy in the file:
    ┌───────────┐
    │           │
    │    Any    │ Superclass of every Kotlin's classes.
    │           │
    └─────▲─────┘
          │
    ┌─────┴─────┐
    │           │
    │     A     │ Open to extensions. Define two properties: `foo` and `bar`.
    │           │
    └─────▲─────┘
          │
    ┌─────┴─────┐
    │           │
    │     B     │ Closed to extensions. Define one new property: `zig`
    │           │
    └───────────┘

*/ 

field _A_foo: Int;
field _A_bar: Int;

field _B_zig: Int;

predicate t_class_A(this: Ref) 
{
    acc(this._A_foo) && acc(this._A_bar)
}

predicate t_class_B(this: Ref)
{
    t_class_A(this) && acc(this._B_zig)
}

method _A_new(foo: Int, bar: Int) returns (this: Ref)
    requires true
    ensures t_class_A(this)
    ensures unfolding t_class_A(this) in this._A_foo == foo
    ensures unfolding t_class_A(this) in this._A_bar == bar
{
    this := new(_A_foo, _A_bar)
    this._A_foo := foo
    this._A_bar := bar
    fold t_class_A(this)
}

function _A_get_foo(this: Ref): Int
    requires t_class_A(this)
    ensures unfolding t_class_A(this) in result == this._A_foo
{
    unfolding t_class_A(this) in this._A_foo
}

function _A_get_bar(this: Ref): Int
    requires t_class_A(this)
    ensures unfolding t_class_A(this) in result == this._A_bar
{
    unfolding t_class_A(this) in this._A_bar
}

function _A_sum(this: Ref): Int
    requires t_class_A(this)
    ensures unfolding t_class_A(this) in result == (this._A_foo + this._A_bar)
{
    unfolding t_class_A(this) in this._A_foo + this._A_bar
}

method _B_new(zig: Int, foo: Int, bar: Int) returns (this: Ref)
    requires true
    ensures t_class_B(this)
    ensures unfolding t_class_B(this) in this._B_zig == zig
    ensures unfolding t_class_B(this) in (unfolding t_class_A(this) in this._A_foo == foo)
    ensures unfolding t_class_B(this) in (unfolding t_class_A(this) in this._A_bar == bar)
{
    this := new(_A_foo, _A_bar, _B_zig)
    this._B_zig := zig
    this._A_foo := foo
    this._A_bar := bar
    fold t_class_A(this)
    fold t_class_B(this)
}

function _B_get_zig(this: Ref): Int
    requires t_class_B(this)
    ensures unfolding t_class_B(this) in result == this._B_zig
{
    unfolding t_class_B(this) in this._B_zig
}

function _B_get_foo(this: Ref): Int
    requires t_class_B(this)
    ensures unfolding t_class_B(this) in (unfolding t_class_A(this) in result == this._A_foo)
{
    unfolding t_class_B(this) in (unfolding t_class_A(this) in this._A_foo)
}

function _B_get_bar(this: Ref): Int
    requires t_class_B(this)
    ensures unfolding t_class_B(this) in (unfolding t_class_A(this) in result == this._A_bar)
{
    unfolding t_class_B(this) in (unfolding t_class_A(this) in this._A_bar)
}

method driver0() 
{
    var a: Ref 
    a := _A_new(10, 20)

    var foo: Int
    var bar: Int
    var sum: Int

    foo := _A_get_foo(a)
    bar := _A_get_bar(a)
    sum := _A_sum(a)

    assert foo == 10
    assert bar == 20

    assert sum == 30
}

method driver1()
{
    var b: Ref
    b := _B_new(10, 20, 30) // B(zig, foo, bar)

    // Check the value of b.zig == 10
    var zig: Int
    zig := _B_get_zig(b)
    assert zig == 10

    // Check the value of b.foo == 20
    var foo: Int
    foo := _B_get_foo(b)
    assert foo == 20

    // Check the value of b.bar == 30
    var bar: Int
    bar := _B_get_bar(b)
    assert bar == 30
}