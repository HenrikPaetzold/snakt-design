/***

// The @Pure annotation is similar to what Prusti does, it assumes it is a pure
// mathematical function.

open class A(val foo: Int, val bar: Int) {
    @Pure fun sum(): Int = foo + bar
}

// In this case the class B does not ovveride the `foo` and `bar`
class B(val zig: Int, foo: Int, bar: Int): A(foo, bar) { }

fun testUpperCasting() {
    
    val b = B(zig: 10, foo: 20, bar: 30) 
    val a: A = b as A // Uppercast to its parent

    assert(a.foo == 20)
}

*/

domain ClassType {
    
    function classA(): ClassType
    function classB(): ClassType

    // Can I cast t1 to t2?
    function canCast(t1: ClassType, t2: ClassType): Bool

    axiom axCasting {
        // We can cast B to its parent A
        forall t1: ClassType, t2: ClassType :: t1 == classA() && t2 == classB() ==> canCast(t2, t1)
    }

}


field _A_foo: Int;
field _A_bar: Int;

// Since B is a sub-child of A, it has a super pointer to its parent
field _B__super: Ref;
// Be aware: we are not overriding A fields, therefore, an access to B::foo should point to B::super(A)::foo
field _B_zig: Int;


predicate t_class_A(this: Ref) 
{
    acc(this._A_foo) && acc(this._A_bar)
}

predicate t_class_B(this: Ref)
{
    acc(this._B_zig) && acc(this._B__super) && t_class_A(this._B__super)
}


method _A_new(foo: Int, bar: Int) returns (this: Ref)
    requires true
    ensures t_class_A(this)
    ensures unfolding t_class_A(this) in this._A_foo == foo
    ensures unfolding t_class_A(this) in this._A_bar == bar
{
    this := new(_A_foo, _A_bar)
    this._A_foo := foo
    this._A_bar := bar
    fold t_class_A(this)
}

function _A_sum(this: Ref): Int
    requires t_class_A(this)
    ensures unfolding t_class_A(this) in result == (this._A_foo + this._A_bar)
{
    unfolding t_class_A(this) in this._A_foo + this._A_bar
}

function _A_get_foo(this: Ref): Int
    requires t_class_A(this)
    ensures unfolding t_class_A(this) in result == this._A_foo
{
    unfolding t_class_A(this) in this._A_foo
}

function _A_get_bar(this: Ref): Int
    requires t_class_A(this)
    ensures unfolding t_class_A(this) in result == this._A_bar
{
    unfolding t_class_A(this) in this._A_bar
}

method _B_new(zig: Int, foo: Int, bar: Int) returns (this: Ref)
    requires true
    ensures t_class_B(this)
    ensures unfolding t_class_B(this) in this._B_zig == zig
    ensures unfolding t_class_B(this) in (unfolding t_class_A(this._B__super) in this._B__super._A_foo == foo)
    ensures unfolding t_class_B(this) in (unfolding t_class_A(this._B__super) in this._B__super._A_bar == bar)
{
    // Initialize parent of B
    this := new(_B__super, _B_zig)

    var super: Ref
    super := _A_new(foo, bar)

    this._B__super := super
    this._B_zig := zig

    fold t_class_B(this)
}

function _B_get_zig(this: Ref): Int
    requires t_class_B(this)
    ensures unfolding t_class_B(this) in result == this._B_zig
{
    unfolding t_class_B(this) in this._B_zig
}

/**
    B::foo and B::bar are not overridden, therefore they point
    to the super class A (A::foo, A::bar)
*/

function _B_get_foo(this: Ref): Int
    requires t_class_B(this)
    ensures unfolding t_class_B(this) in (unfolding t_class_A(this._B__super) in result == this._B__super._A_foo)
{
    unfolding t_class_B(this) in (unfolding t_class_A(this._B__super) in this._B__super._A_foo)
}

function _B_get_bar(this: Ref): Int
    requires t_class_B(this)
    ensures unfolding t_class_B(this) in (unfolding t_class_A(this._B__super) in result == this._B__super._A_bar)
{
    unfolding t_class_B(this) in (unfolding t_class_A(this._B__super) in this._B__super._A_bar)
}

method driver0() 
{
    var a: Ref 
    a := _A_new(10, 20)

    var foo: Int
    var bar: Int

    foo := _A_get_foo(a)
    bar := _A_get_bar(a)

    assert foo == 10
    assert bar == 20
}

method driver1()
{
    var b: Ref
    b := _B_new(10, 20, 30) // B(zig, foo, bar)

    // Check the value of b.zig == 10
    var zig: Int
    zig := _B_get_zig(b)
    assert zig == 10

    // Check the value of b.foo == 20
    var foo: Int
    foo := _B_get_foo(b)
    assert foo == 20

    // Check the value of b.bar == 30
    var bar: Int
    bar := _B_get_bar(b)
    assert bar == 30
}