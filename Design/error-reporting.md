# Error Reporting Design Document

This document aims to explain how the error reporting works in our plugin.

## Integrating context information on Viper's AST Nodes

As we were able to embed Kotlin's source information into the AST nodes, we now move forward to embed *context
information*.
This information is used to interpret the errors generated by Viper during the verification phase, so we can
report errors in a more human-readable way. Let us give an example.

```Kotlin
fun badContract(f: () -> Unit) {
    contract {
        callsInPlace(f, InvocationKind.EXACTLY_ONCE)
    }
    f()
    f()
}
```

The function shown in the listing above fails the contract verification, since the function `f` is called twice, while
we request to be called only once.
Currently, our tool generates error messages coming from Viper, like this:
```text
warning: Post-condition failed on function `badContract`, the assertion might not hold.
```

When we iterate through the verification errors, Viper exposes two important metadata:
1. Position: Where the problem originated (we store Kotlin's source in there).
2. Info: Additional information.

Therefore, having access to the info metadata allows us to understand the error's context during the *reporting phase*.

We ask ourselves two important questions:
1. What information should be put in the context?
2. How should it be interpreted and reported?

In this section, we are going to propose a solution to these answers.

### Embedding Context Info

Embedding the context information happens during the code generation phase. At the moment, we support the following
Kotlin Contract effects:
1. `callsInPlace`: *guarantee that a parameter with a functional type is called in place during function execution*.
2. Conditional Effects. `returns (...)` / `returns (...) implies (...)`

For each of these effects, we need to understand what information is important to generate a meaningful error message.

#### Calls in Place

The first effect, `callsInPlace`, informs the compiler that a given function parameter will be called a specific number
of times. The effect accepts two parameters: the *targeted function parameter* and the *kind of invocation*. 
We have four kinds of invocations: `EXACTLY_ONCE`, `AT_MOST_ONCE`, `AT_LEAST_ONCE` and `UNKNWON`. 
When Viper generates a verification error on these effects, the user must understand:
1. Who is the targeted function.
2. What went wrong with the invocation kind. 

So, if we have a contract stating to call a function `EXACTLY_ONCE`, then the message must inform that the function
*could be possibly* called more than once, or never (see the message below).

```text
warning: In function `badContract`, the contract `callsInPlace(f, InvocationKind.EXACTLY_ONCE)` might not be fulfilled. 
The parameter `f` passed to `badContract` might not be called *just once* along all possible execution paths.
```

The above warning message points out in what function the contract is violated, who is the targeted function (`f`) and
why the contract might not be fulfilled. So, the warning message template for `callsInPlace` would be the following one:

```text
warning: In function `{0}`, the contract `{1}` might not be fulfilled. The parameter `{2}` passed to `{0}` might not
be called *{3}* along all possible execution paths.
```

Where the placeholders have the following meaning: `{0}` is the function's name, `{1}` the violated contract effect,
`{2}` the targeted function, and `{3}` is the reason why, given by the invocation kind. For each invocation kind
we have the following messages:

1. `EXACTLY_ONCE`: `just once`.
2. `AT_MOST_ONCE`: `at most once`.
3. `AT_LEAST_ONCE`: `at least once`.
4. `UNKNWON`: `with a known invocation kind`.

#### Conditional Effects

The second effect `returns(...) implies (...)` implies some value-type implications based on the *result of the
function*. The compiler uses this feature for smart-casting. As done previously with the `callsInPlace` effect, let us
analyze what is the necessary information to track to report a human-readable message. The effect is written as follows:

```text
Effect ==> Condition 
```

The meaning of the contract is: **If the effect is observed, then the condition is guaranteed to be true**. Therefore,
we should report to the user stating that the condition might not be true because the returned value is not the expected
one. The information to track is:
1. The observed effect.
2. The condition that must hold.

```text
warning: In function `{0}`, the contract `{1}` might not be fulfilled. The condition `{2}` might not hold
because the function can return a value different from the expected one `{3}`.
```

The error message can be broken in the following parts: `{0}` is the function's name, `{1}` is the violated effect,
`{2}` is the condition, and `{3}` is the expected returned value.

The conditional effect can also be composed by `returns(...)` without the implication part. In this case,
the error message changes as follows:

```text
warning: In function `{0}`, the contract `{1}` might not be fulfilled. The returned value might not be the
expected one `{3}`.
```

It is worth noting that the *condition* can be an `is instance of` predicate. In that case, the error message
can be changed as follows.

```text
warning: In function `{0}`, the contract `{1}` might not be fulfilled. The returned value's instance
might be different from `{4}`.
```

Where the placeholder `{4}` is the expected instance type.

### Data Structures

We embed this context information into the Viper's Info metadata. To do so, we have to create a new Info class,
similar to the wrapped Position one. We assign the information only to AST nodes corresponding to the
contract's effects.

```Kotlin
// Rough sketch on context classes...

value class Effect(val exp: Exp)
data class Condition(val exp: Exp, val isPredicate: Bool)

sealed class ContextInfo {
    data class CallsInPlace(
        val targetFunction: KtSourceElement?, 
        val invocationKind: EventOccurrencesRange
    ): ContextInfo()
    
    data class ConditionalEffect(
        val effect: Effect,
        val condition: Condition?
    ) : ContextInfo()
}
```
