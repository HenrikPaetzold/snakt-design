This document explains what are the current challenges faced during error reporting.

## Problem Statement

After the implementation of [error reporting](generated-errors.md), a new challenge arose: 
rebuilding missing context information.

Context information refers to the details needed to understand and interpret Viper’s verification errors. 
More specifically, we lack information in two cases, when: a lambda function may leak from a `callsInPlace` effect,
and for standard library functions (e.g., lists pre-conditions). 

When we are testing Kotlin functions making use of the two cases, Viper generates a `PreconditionInCallFalse`. 
Therefore, it is reasonable to think to create a shared error logic to handle such cases 
(having the `PreconditionInCallFalse`) in common.

Let us analyze the generic form of when an error happens:

Program in Kotlin:

```kotlin
fun escape(h: () -> Unit) = h()

fun driver(f: () -> Unit) { 
    contract { callsInPlace(f) }    
    escape(f)
}
```

This is the corresponding code in Viper (we use the special call to `duplicable` to point out that the given
lambda parameter can be copied at runtime, and therefore, not unique):

```viper
method escape(local$h: Ref) returns (ret: dom$Unit)    
    requires special$duplicable(local$h)    
    // ....

method driver(local$f: Ref) returns (ret: dom$Unit)   
    // ...
{
    var anon$0: dom$Unit    
    // ...    
    anon$0 = escape(local$f) // (MethodCall)
             ^~~~~~~~~~~~~~~~~ PreConditionInCallFalse
}
```

> Note: the two code listings omit additional statements not necessary for this document.

When a `PreconditionInCallFalse` arises from the verification phase, we have two main points of interest:

1. The method call-site `anon$0 = escape(local$f)`, and

2. The reason for the failing precondition, instantiated with the actual parameter causing the assertion to fail: 
`requires special$duplicable(local$f)` (notice how the name `local$h` has been replaced).

Both these two points are mentioned in the result data generated by a `PreconditionInCallFalse` error. The question is:
how we can use such information to understand what went wrong? Let us focus on the leaking `callsInPlace` for the moment,
analyzing the information that Viper provides us. 

> Note: error reporting happens after code-generation phase, we do not have access to variable embeddings anymore.
> In addition, the class responsible to report and interpret the warnings is `VerifierErrorInterpreter`, that is
> contained in a different Kotlin package, constraining ourselves in the data we can access.

Thanks to the `SourceRole` information embedded into `special$duplicable`, we can understand that the 
pre-condition error has to do with leakable lambda parameters. What we need is the reference of the function that is
leaking, the *actual parameter* of `special$duplicable`. In an instance of `PreconditionInCallFalse`, as previously
mentioned in point two, Viper replaces the formal parameter with the actual one. The key to the problem’s solution
is to use the actual parameter. We have three paths:

1. Understand how much information is retained by the variable embedding representing the lambda parameter, and
then attach additional info. This is not trivial, since we do not know if a variable embedding will live long enough.

2. Decentralize the extra-information in an ad-hoc new data-structure used to track this information to be later used
by the error reporting phase.

3. An hybrid approach: use a data-structure to track all the extra-information attached to a variable/parameter with
an ad-hoc data-structure, and then embed the collected information on the call-site of the method causing the pre-condition
error. 

The following table summarizes the pros and cons for each proposed solution.

| Solution                              | Pros                                                     | Cons                                                             |
| ------------------------------------- | -------------------------------------------------------- | ---------------------------------------------------------------- |
| 1. Attach info to Variable Embeddings | Direct context to variable. Simplifies error tracing.   | Complexity in lifespan management. Risking for information loss. |
| 2. Decentralized data-structure       | Simplifies management of context info. Easier to extend. | Complexity in mapping info back to error.                        |
| 3. Hybrid approach                    | Balances the two previous solutions.                     | Increased initial complexity. More effort to maintain. |

Upon evaluating these options, the hybrid approach is selected for its balanced benefits

I will proceed illustrating the third solution, since it seems a good balance point with the other two. 
The next section divides the solution in three parts: 

1. collecting information for variable embeddings.
2. attach the collected info into the actual parameters of a method call.
3. use the extra information on method call’s argument to rebuild missing information.

### Solution Proposal

This solution is also adaptable for list functions (we will focus only on leak `callsInPlace`). 
Let us break down the main working process.

#### Tracking and adding information

First, we need a data-structure to collect context information to add to arguments of a method call (see the
definition of the class `MethodCall`).

```kotlin
data class MethodCall(val method: NamedFunctionSignature, val args: List<ExpEmbedding>) : StoredResultExpEmbedding
```

We call this data-structure `SourceRoleTracker`. As the name implies, it is used to collect source role information
of a given variable embedding. The data-structure definition is illustrated in the next listing.

```kotlin
class SourceRoleTracker {
    private val trackedSourceRoles: MutableMap<String, MutableSet<SourceRole>> = mutableMapOf()

    /**
    * Associates a new source role with a variable embedding. If an existing source role is already
    * associated with the variable embedding, the new role will replace the previous one.
    */
    fun addSourceRoleToVariable(key: String, newRole: SourceRole) : SourceRole {
        // Implementation details omitted.
    }

    /**
    * Retrieves all source roles associated with a given variable embedding.
    */
    fun retrieveSourceRoles(key: String) : List<SourceRole> {
        // Implementation details omitted.
    }
}
```

> Note: a good key element is the variable embedding’s mangled name, since it uniquely identifies a variable from
> the Kotlin source.

The `SourceRoleTracker` can be added to the `MethodConversionContext`, so it would be available from the 
`StmtConversionVisitor`. Once we generate a `MethodCall` we embed all the collected information into the method’s call
arguments.

##### Leaking lambda parameter from `callsInPlace`

The `SourceRoleTracker` will gather information from the `ContractConversionVisitor` about the “installed” effects
on a given function parameter. For example, during the visit of `callsInPlace(f, AT_MOST_ONCE)` we can embed the 
existing `SourceRole.CallsInPlaceEffect` to `f` using the `SourceRoleTracker`.

```kotlin
class ContractDescriptionConversionVisitor(
    private val ctx: ProgramConversionContext,
    private val signature: NamedFunctionSignature,
    private val sourceRoleTracker: SourceRoleTracker,
) : KtContractDescriptionVisitor<ExpEmbedding, ContractVisitorContext, ConeKotlinType, ConeDiagnostic>() {

    override fun visitCallsEffectDeclaration(
            callsEffect: KtCallsEffectDeclaration<ConeKotlinType, ConeDiagnostic>,
            data: ContractVisitorContext,
        ): ExpEmbedding {
            // Additional code ...
            val sourceRole = SourceRole.CallsInPlaceEffect(targetLambdaByCallsEffect, callsEffect.kind)
            val varEmbedding = callsEffect.valueParameterReference.embeddVar()
            sourceRoleTracker.addSourceRoleToVariable(varEmbedding.mangledName.mangled, sourceRole)
            // Rest of the code ...
    }
}
```

#### Rebuilding Lost Information

During the error reporting phase, we leverage the embedded information in method call arguments to decode Viper errors.

##### Finding the leaked function from `callsInPlace`

Now, when we get a `PreconditionInCallFalse` error and as source role fetched from the error we have an instance of
`ParamFunctionLeakageCheck`, we are able to understand that the generated error has to do with a lambda parameter
that may leak from its `callsInPlace` contract, and we are also able to address the “guilty” function. To do so,
we will define a new method that use the actual parameter instance on the `special$duplicable` function and perform
a lookup on the method-call info that we have. Once the lookup is done, we can fetch the extra information we embedded
during the first phase.

## Conclusions

Implementing the `SourceRoleTracker` as part of the `MethodConversionContext` will allow us to collect and 
utilize context information, therefore improving the precision of our error reporting. 
By embedding this information directly at the method call-site, we enable a more intuitive error tracing process 
that aligns with the developers’ understanding of the code.

As we move forward with an implementation, it would be interesting to monitor how effective the `SourceRoleTracker` is.