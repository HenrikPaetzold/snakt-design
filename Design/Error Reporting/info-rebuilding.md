## Introduction

After the implementation of [error reporting](generated-errors.md), we have a new problem in understanding
how to get missing information to build a warning message.

We lack information in two cases, when: 

1. a lambda function may leak from a `callsInPlace` effect: we do not know what is the target function by the
`callsInPlace` effect.

2. for standard library functions (e.g., lists pre-conditions): we do not know any information on the list,
such as its initial size, name and signature.

Those two cases share the same Viper error. Thus, we should find an approach that allow us to share the same logic.

*This document focuses only on the first point*.

## What we have

When we try to run the test cases for the two points of above, Viper generates a `PreconditionInCallFalse` error.
The error contains the reference to the method-call site, and what precondition is failing. 
In the precondition application, Viper replace the formal parameters with the actual ones. 

Let us see what error Viper generates for us when we try to run the `calls_in_place_leak.kt` test file. We have the 
following Kotlin program:

```kotlin
fun escape(h: () -> Unit) = h()

fun driver(f: () -> Unit) { 
    contract { callsInPlace(f) }    
    escape(f)
}
```

This is the corresponding code in Viper:

```viper
method escape(local$h: Ref) returns (ret: dom$Unit)    
    requires special$duplicable(local$h)    
    // ....

method driver(local$f: Ref) returns (ret: dom$Unit)   
    // ...
{
    var anon$0: dom$Unit    
    // ...    
    anon$0 = escape(local$f)
             ^~~~~~~~~~~~~~~ // (HERE) This is point where Viper reports an error.
}
```

> Note: the two code listings omit additional statements not necessary for this document.

The error is generated after the verification phase, therefore, we only have information provided by Viper’s error.
In the listing above, the `(HERE)` label mark where Viper generates an error, in this case we get a 
`PreconditionInCallFalse`.

When a `PreconditionInCallFalse` arises from the verification phase, we have two main points of interest:

1. The method call-site `anon$0 = escape(local$f)`, and

2. The reason for the failing precondition, instantiated with the actual parameter causing the assertion to fail: 
`requires special$duplicable(local$f)` (notice how the name `local$h` has been replaced).

Both these two points are mentioned in the result data generated by a `PreconditionInCallFalse` error. The question is:
how we can use such information to understand what went wrong?

From the error, we have:

1. the variable causing the precondition to fail.

2. what precondition failed.

3. the method-call generating the Viper’s error.

We need to understand why the error generated. The error generated because a lambda function parameter may 
leak from its `callsInPlace` contract. So, we can embed a new `SourceRole` in the pre-condition, so that when
we get the error we may know from that pre-condition that we are dealing with a possible lambda parameter leak.
We call this new `SourceRole`: `ParamFunctionLeakage` and we embed it into the function application `special$duplicable`
info metadata.

Next, how do we know who is the function is trying to escape from the contract? From the error we know what variable
is making generating an error. But, we do not have *any* information of the original source code. So, how do we
fix that? We need to embed or fetch some missing information on that Viper’s variable. Therefore, to do so, we have one straightforward solution.

## The Solution

Basically, we need a way to add the missing source information on the Viper’s variable that is causing the error.
And then, from that variable, we can fetch the information and generate a proper warning message.

In the current tool version, we represent Viper’s variables using `VarEmbedding`s. The `VarEmbedding`’s sub-child we are interested in
is:

```kotlin
class FirVariableEmbedding(
    override val name: MangledName, 
    override val type: TypeEmbedding, 
    val symbol: FirBasedSymbol<*>
) : VariableEmbedding
```

Therefore, we can override the `toViper` method of `FirVariableEmbedding` to embed the `symbol` parameter
as Viper’s info metadata:

```kotlin
// FirUtils.kt
val FirBasedSymbol<*>?.asInfo: Info
    get() = when (this) {
        null -> Info.NoInfo
        else -> Info.Wrapped(this)
    }

// VariableEmbedding.kt

class FirVariableEmbedding(
    override val name: MangledName, 
    override val type: TypeEmbedding, 
    val symbol: FirBasedSymbol<*>
) : VariableEmbedding {
    override fun toViper(source: KtSourceElement?): Exp.LocalVar = 
        Exp.LocalVar(name, type.viperType, source.asPosition, symbol.asInfo)
}
```

Embedding the symbol as information into the variable embedding allow us to fetch it during error reporting:
```kotlin
private fun DiagnosticReporter.reportVerificationErrorUserFriendly(
        source: KtSourceElement?,
        error: VerificationError,
        context: CheckerContext,
) {
    val role = error.getInfoOrNull<SourceRole>()
    when {
        // ...
        error is PreconditionInCallFalse && role is SourceRole.ParamFunctionLeakageCheck -> {
            val param: FirBasedSymbol<*> = error.extractInfoFromFunctionArgument(role.index).unwrapOr { 
                error("missing extra information") // This cannot happen!
            }
            reportOn(source, PluginErrors.LAMBDA_MAY_LEAK, param!!, context)
        }
        else -> reportVerificationErrorOriginalViper(source, error, context)
    }
}
```