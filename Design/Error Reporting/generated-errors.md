This document aims to illustrate what are the errors generated by Viper.

---

We start distinguishing two types of errors:

1. **Consistency Errors**: what is wrong according to the semantic of a Viper program (e.g., not well-formed method 
invocation, access predicates, ...). These errors are useful for internal usage if they were to happen
from a user's side, then it would be a good idea allowing reporting it to us.

2. **Verification Errors**: generated by Viper during the verification process. When these errors are thrown
we want to warn the user about misusage in list functions, or about a function not satisfying a Kotlin contract.

The verification errors are the most important for the end-users, they must allow the user to understand
what went wrong with the code they wrote. The error messages should be as explicit as possible, pointing out
what is the reason why the error (and maybe in the future, providing some suggestions to fix the problems).

## Consistency Errors

Consistency errors are meant to be used internally within our team to diagnose what went wrong with Viper's code
generation. As said previously, if they were to happen in production, we should provide a way for the user to create
an automatic report for us.

## Verification Errors

Verification errors are essential for end-users, they should be able to understand what is wrong with the code 
and then fix it. At the moment of writing of this document, we are focusing on:

1. Kotlin Contracts: conditional effects and calls in place.
2. List access functions: possible out-of-bound errors at runtime.

### Generated Errors

This section analyzes the errors generated by Viper during the verification process. The complete lists of generated 
errors can be found [here](https://github.com/viperproject/silver/blob/07dce2bf8a90f6be9443ece6d1697b0e2767fb48/src/main/scala/viper/silver/verifier/VerificationError.scala).

Currently, our test suite for bad contracts considerate the following errors:

*   Type casting errors (`as_type_contract.kt`)
*   Accessing list with out of bound indices (`binary_search.kt`, `list.kt`)
*   Violated calls in place contract (`calls_in_place.kt`)
    *   Leaked function from calls in place contract (`calls_in_place_leak.kt`, `inlining_captured.kt`)
*   Incorrect returned values (`returns_booleans.kt`)
*   Conditional effects violation (`returns_null.kt`)
    *   Implying types (`is_type_contract.kt`)

From this test suite we get three main verification errors by Viper:

1. `PostconditionViolated`: a post-condition on a method's contract is violated.
2. `PreconditionInCallFalse`: a pre-condition fails when invoking a Viper's method.
3. `AssertFailed` (the only case is `calls_in_place_leak.kt`): an assertion statement might not hold.

Every Viper's Verification error has two piece of information along with them: a string identifier and 
a *reason* (explained below).

Our goal is mapping Viper's errors into Kotlin's ones, providing valuable information to the end-users.

Each one of these errors has fields bringing extra information, illustrated in the table below. Each axes is explained
accordingly:

1.  Error Kind: what type of error Viper generated (violation of post-condition, failed pre-condtion, failed assertion).
2.  Reason: it informs the user why the error generated. For violation of pre/post-condition is represented by the
    `AssertionFalse` type. The `reason` field also contains an offending node, usually a child of Viper's AST node where
    verification error is located.
3.  Offending Node: in which Viper's AST node the error is located at.
4.  Extra Fields: other fields carried by the error.
5.  Context: what we were veryfing when the error shown up.
6.  What went wrong: human-readbale reason of why the verification failed.

| Error Kind                	| Reason           	| Offending Node        	| Extra Fields 	| Context                                            	| What went wrong                                                                                                                                              	|
|---------------------------	|------------------	|-----------------------	|--------------	|----------------------------------------------------	|--------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| `PostconditionViolated`   	| `AssertionFalse` 	| Postcondition         	| Method       	| 1. Conditional Effect<br><br>2. Calls in Place     	| 1. The implication of a conditional effect does not hold. <br><br>2. The number of actual calls does not match the invocation kind.                          	|
| `PreconditionInCallFalse` 	| `AssertionFalse` 	| Call-site of a method 	| /            	| 1. Calls in Place Leaking<br><br>2. List Functions 	| 1. Passing a lambda parameter to a function without contracts.<br><br>2. Accessing a list's element out-of-bound (e.g., `val l = emptyList(); val x = l[0]`) 	|
| `AssertFailed`            	| `AssertionFalse` 	| Assert Statement      	| /            	| 1. Calls in Place Leaking                          	| 1. This is a special case in `calls_in_place_leak.kt` when we pass a lambda parameter to another one.                                                        	|                                     	|

The output errors are not human friendly at all, bringing generic error messages to the end-user:
```
/as_type_contract.kt:(194,236): warning: Viper verification error: Postcondition of global$fun_getX$fun_take$T_Any$return$NT_Int might not hold. Assertion ret != (dom$Nullable$null(): dom$Nullable[Int]) ==> !dom$Type$isSubtype((dom$TypeOf$typeOf(local$a): dom$Type), dom$Type$global$class_IntHolder()) might not hold.
```

The example above taken from `as_type_contract.kt` informs us a *post-condition* might not be hold, but it does not 
tell us they why, nor what was the original purpose of this error.

### Digging into Verification Errors

Each error generated by Viper brings three main information:

1.  The kind of error: this is obtained by the error instance's type at runtime.
2.  The reason: why the error was generated. This information, mainly of type `AssertionFalse`, has two main fields: an 
    identifier and the `offendingNode` (who caused the error). The list of reasons can be found [here](https://github.com/viperproject/silver/blob/ce5523d0c902f5ff61c8af49f80cd180f758c5b5/src/main/scala/viper/silver/verifier/VerificationError.scala#L591).
3.  The offending node: where the error generated from the verification process. Notice that this information may be
    different from the one embedded into reason.

**Additional information**:
*   The `Postconditionviolated` error is the only one carrying extra information (i.e., `Method`) pointing out
    in which method the violated postcondtion is located.

TODO: understand how to use this information to translate the Viper errors for end-users.

TODO: the next step would be on how to map these errors back to Kotlin.