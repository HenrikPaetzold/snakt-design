This document aims to illustrate what are the errors generated by Viper.

---

We start distinguishing two types of errors:

1. **Consistency Errors**: what is wrong according to the semantic of a Viper program (e.g., not well-formed method 
invocation, access predicates, …). These errors are useful for internal usage if they were to happen
from a user’s side, then it would be a good idea allowing reporting it to us.

2. **Verification Errors**: generated by Viper during the verification process. When these errors are thrown
we want to warn the user about misusage in list functions, or about a function not satisfying a Kotlin contract.

The verification errors are the most important for the end-users, they must allow the user to understand
what went wrong with the code they wrote. The error messages should be as explicit as possible, pointing out
what is the reason why the error (and maybe in the future, providing some suggestions to fix the problems).

## Consistency Errors

Consistency errors are meant to be used internally within our team to diagnose what went wrong with Viper’s code
generation. As said previously, if they were to happen in production, we should provide a way for the user to create
an automatic report for us.

## Verification Errors

Verification errors are essential for end-users, they should be able to understand what is wrong with the code 
and then fix it. At the moment of writing of this document, we are focusing on:

1. Kotlin Contracts: conditional effects and calls in place.
2. List access functions: possible out-of-bound errors at runtime.

### Generated Errors

This section analyzes the errors generated by Viper during the verification process. The complete lists of generated 
errors can be found [here](https://github.com/viperproject/silver/blob/07dce2bf8a90f6be9443ece6d1697b0e2767fb48/src/main/scala/viper/silver/verifier/VerificationError.scala).

Currently, our test suite for bad contracts considerate the following errors:

*   Type casting errors (`as_type_contract.kt`)
*   Accessing list with out of bound indices (`binary_search.kt`, `list.kt`)
*   Violated calls in place contract (`calls_in_place.kt`)
    *   Leaked function from calls in place contract (`calls_in_place_leak.kt`, `inlining_captured.kt`)
*   Incorrect returned values (`returns_booleans.kt`)
*   Conditional effects violation (`returns_null.kt`)
    *   Implying types (`is_type_contract.kt`)

From this test suite we get three main verification errors by Viper:

1. `PostconditionViolated`: a post-condition on a method’s contract is violated.
2. `PreconditionInCallFalse`: a pre-condition fails when invoking a Viper’s method.
3. `AssertFailed` (the only case is `calls_in_place_leak.kt`): an assertion statement might not hold.

Every Viper’s Verification error has two piece of information along with them: a string identifier and 
a *reason* (explained below).

Our goal is mapping Viper’s errors into Kotlin’s ones, providing valuable information to the end-users.

Each one of these errors has fields bringing extra information, illustrated in the table below. Each axes is explained
accordingly:

1.  Error Kind: what type of error Viper generated (violation of post-condition, failed pre-condtion, failed assertion).
2.  Reason: it informs the user why the error generated. For violation of pre/post-condition is represented by the
    `AssertionFalse` type. The `reason` field also contains an offending node, usually a child of Viper’s AST node where
    verification error is located.
3.  Offending Node: in which Viper’s AST node the error is located at.
4.  Extra Fields: other fields carried by the error.
5.  Context: what we were veryfing when the error shown up.
6.  What went wrong: human-readbale reason of why the verification failed.

| Error Kind                	| Reason           	| Offending Node        	| Extra Fields 	| Context                                            	| What went wrong                                                                                                                                              	|
|---------------------------	|------------------	|-----------------------	|--------------	|----------------------------------------------------	|--------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| `PostconditionViolated`   	| `AssertionFalse` 	| Postcondition         	| Method       	| 1. Conditional Effect<br><br>2. Calls in Place     	| 1. The implication of a conditional effect does not hold. <br><br>2. The number of actual calls does not match the invocation kind.                          	|
| `PreconditionInCallFalse` 	| `AssertionFalse` 	| Call-site of a method 	| /            	| 1. Calls in Place Leaking<br><br>2. List Functions 	| 1. Passing a lambda parameter to a function without contracts.<br><br>2. Accessing a list’s element out-of-bound (e.g., `val l = emptyList(); val x = l[0]`) 	|
| `AssertFailed`            	| `AssertionFalse` 	| Assert Statement      	| /            	| 1. Calls in Place Leaking                          	| 1. This is a special case in `calls_in_place_leak.kt` when we pass a lambda parameter to another one.                                                        	|                                     	|

The output errors are not human friendly at all, bringing generic error messages to the end-user:
```
/as_type_contract.kt:(194,236): warning: Viper verification error: Postcondition of global$fun_getX$fun_take$T_Any$return$NT_Int might not hold. Assertion ret != (dom$Nullable$null(): dom$Nullable[Int]) ==> !dom$Type$isSubtype((dom$TypeOf$typeOf(local$a): dom$Type), dom$Type$global$class_IntHolder()) might not hold.
```

The example above taken from `as_type_contract.kt` informs us a *post-condition* might not be hold, but it does not 
tell us they why, nor what was the original purpose of this error.

### Digging into Verification Errors

Each error generated by Viper brings three main information:

1.  The kind of error: this is obtained by the error instance’s type at runtime.
2.  The reason: why the error was generated. This information, mainly of type `AssertionFalse`, has two main fields: an 
    identifier and the `offendingNode` (who caused the error). The list of reasons can be found [here](https://github.com/viperproject/silver/blob/ce5523d0c902f5ff61c8af49f80cd180f758c5b5/src/main/scala/viper/silver/verifier/VerificationError.scala#L591).
3.  The offending node: where the error generated from the verification process. Notice that this information may be
    different from the one embedded into reason.

**Additional information**:

*   The `Postconditionviolated` error is the only one carrying extra information (i.e., `Method`) pointing out
    in which method the violated postcondtion is located.


As said previously, the `reason` field in a `VerificationError` contains the `offendingNode` causing the Viper’s error.
The `offendinNode` can be a sub-expression of the original expression where the error was generated.
Each Viper’s node has three metadata information: the *position*, an *info* and an error transformer. We can
use the `info` metadata to store information to be used during error reporting/translation phase. Or, we can use 
an approach similar to the one from [Nagini](https://github.com/marcoeilers/nagini) and [Prusti](https://github.com/viperproject/prusti-dev). 

However, Nagini and Prusti are written in different languages, therefore, to avoid some performance penalty due
to the FFI with the JVM (Silicon is writte in Scala), they adopted some tricks discussed later in the section.

### Embedding Context Information

As mentioned in the previous section, when translating errors from Viper into Kotlin warning, we need a way to
interpret them accordingly. To do so, we propose two solutions, having a common denominator: *embedding error context 
information* during codegen phase. An **error context information** is an extra piece of info added to a generated Viper’s
AST node. The kind of information can be related on *what* we are analyzing. For example, if we are generating Viper’s
code for Kotlin’s lists access, we can embedd an information on what could go wrong when a `PreconditionInCallFalse` is
raised. For example, if we are accessing a list element, we add an information of type `AccessingList` (n.b., the name
is not definitive). Thus, during the error-translation phase, when we analyze the pre-condition error we can access to
this extra info, and generate a proper human-readable message, like:

```text
warning: accessing the list `l` may cause a runtime exception.
```

The more information we want to provide the user, the more context we need to embed during the codegen phase. The 
following table summarizes all the info that, at the moment, we are interested into:

| Error Context Information    | When embed this information                                     | Additional Metadata | Example File                                 | Possible Error Message                                                                |
| ---------------------------- | --------------------------------------------------------------- | ------------------- | -------------------------------------------- | ------------------------------------------------------------------------------------- |
| `IndexInBoundCondition`            | Accessing a list element with the index operator.               | * The list’s size.  | `list.kt`, `binary_search.kt`                | `warning: indexing the list with the provided index may result in a runtime exception.` |
| `SublistInBoundCondition`          | Creating a sublist with two wrong interval ranges.              | * The list’s size.  | `binary_search.kt`                           | `warning: the interval indices are not contained between the list's size.`            |
| `DublicableLambda`     | Passing a lambda parameter targeted by a `callsInPlace` effect. | -                   | `calls_in_place_leak.kt`                     | `warning: the following lambda parameter may leak outside this function.`             |
| `IsSubType`      | Implication on returning type of a conditional contract.        | -                   | `as_type_contract.kt`, `is_type_contract.kt` | `warning: the returned type might be different from the stated one.`                  |
| `CondEffect` | Conditional effect given by an implication.                     | -                   | `returns_boolean.kt`, `returns_null.kt`      | `warning: the implication's consequence might not hold.`                              |

The embedding of this information will allow us to generate proper error messages.

Now, the question is: *how do embed this extra context information*? We have two possible ways:

1.  Adding the context information on the `info` field of a Viper AST node.
2.  Keeping an error context collector during the code generation phase, and insert unique errors, while we generate AST Viper’s Node,
    with an associated context information.

#### First Approach

The first way, consists in defining a new error context information to be embedded as `Info` data structure into a Viper’s
AST node. Embedding this information in a Viper’s AST Node metadata would be similar to the work we have done with
positions (i.e., create a wrapper around the context information we want to save). Using the table defined above, we can 
define an error context information as it follows.

```kotlin
sealed class ErrorContextInfo {
    object IndexInBoundCondition    : ErrorContextInfo()
    object SublistInBoundCondition  : ErrorContextInfo()
    object DublicableLambda         : ErrorContextInfo()
    object IsSubType                : ErrorContextInfo()
    object CondEffect               : ErrorContextInfo()
} 
```

Having the `ErrorContextInfo`, we can create a new Viper’s Info sub-child wrapping the information and embed it
into a Viper’s Node AST metadata.

```kotlin
data class WrappedInfo<I>(val wrapped: I) : viper.silver.ast.Info
```

Then, during the error reporting phase, we can unwrap the information and generate an error accordingly (explained
in the [Translating Verification Errors section](#translating-verification-errors)).

Pros:
* This approach is straightforward to implement.
* Error Context Information is embedded directly into Viper’s AST Node.

Cons:
* Maybe is too basic for tracking more information per node?

#### Second Approach

The second approach consists of creating an error context collector info, similar to what Gobra, Prusti and Nagini do.
According to Prusti’s team, this solution came up from using Viper with another programming language different than a
JVM one. With Kotlin we do not have this problem, since it is compiled in JVM bytecode. However, let us analyze
the error reporting process, and how it could be fitted in our plugin.

1.  Creating a *error context information* collector when verifying a function. This data structure would behave
    as a central point used during the error reporting phase. Its scope will be clearer as follows.
2.  Instead of embedding the *error context information* on a Viper’s AST node, we use a collector’s instance
    to register that information with a unique identifier. This identifier is embedded into Viper’s AST node `info`
    metadata.
3.  During the error-reporting phase, since each `VerificationError` has an `offendingNode`, we can retrieve
    the identifier and use it to get the error context information. Then, having the Viper’s error and the context
    we can output a warning accordingly.

The main difference between the two approaches is how they keep the error context information. The second approach
is more centralized compared to the previous one. But as stated in the introduction, this solution was a way
to lower the overhead times caused by the FFI and the Java Virtual Machine.

Pros:
* Better for large error contexts.

Cons:
* Implementation may not be straightforward, and it would need a way to generate unique identifiers.

#### Additional Notes

Both approaches allow concatenating context information. For example, if we want to give an advanced error’s 
explanation to the user for `ListAccessing`, we can store the list’s size. So, the message can become like the
following:

```text
warning: indexing the list with the provided index may result in a runtime exception. The list's size is empty!
```

### Where to place Context Error Information

This section illustrates where on what nodes the error context information should be embedded.

#### List Functions

> TLDR; embed the error context information on `PreconditionInCallFalse`’s offending node, that is, the `MethodCall`
node generated for the corresponding Kotlin’s function.

Currently, for list functions, we have two “kind” of contracts:

1. Accessing a list’s element via index.
2. Creating a new sub-list given two range indices.

When the verification errors raised by Viper occur, we have an instance of `PreconditionInCallFalse`. We can embed
the error context information on the method calls representing the Kotlin list function. So, for (1) we
embed a error context information of type `IndexInBoundCondition`, and for (2) `SublistInBoundCondition`.

#### Leak calls in place

We know that a lambda parameter may leak from a function’s contract when the 
`PreconditionInCallFalse`/`AssertFailed` is raised by Viper, and the offending node contains an implicit
call to the `duplicale` built-in function. In this case, we can embed the `DublicableLambda` error context 
information into the `FuncApp` node for the special built-in `duplicable` function.

#### Conditional Effects

Conditional effects errors are represented by `PostconditionViolated` errors. When the conditional error is of the
form `Implies` (left → right), then we can embed a specific error context information on the right implication side.
In the case we are dealing with `returns()` clause without right side, we embed the info directly on the corresponding
Viper’s AST Node.

For example:
*   `bad_contracts/is_type_contract.kt`: we can embed a error context information of type `IsSubType` on 
    the right’s implication side (that is a `DomainFuncApp`).
*   `bad_contracts/as_type_contract.kt`: we can embed a `IsSubType` on the right’s implication (that is
    a `Not` of `DomainFuncApp`).
*   `bad_contracts/returns_null.kt`: we can embed a `CondEffect` on the `FalseLit` node.

### Translating Verification Errors

TODO: where we are going to add this info.

TODO: understand how to use this information to translate the Viper errors for end-users.

TODO: the next step would be on how to map these errors back to Kotlin.