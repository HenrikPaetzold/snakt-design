This document aims to illustrate what are the errors generated by Viper.

---

We start distinguishing two types of errors:

1. **Consistency Errors**: what is wrong according to the semantic of a Viper program (e.g., not well-formed method 
invocation, access predicates, ...). These errors are useful for internal usage if they were to happen
from a user's side, then it would be a good idea allowing reporting it to us.

2. **Verification Errors**: generated by Viper during the verification process. When these errors are thrown
we want to warn the user about misusage in list functions, or about a function not satisfying a Kotlin contract.

The verification errors are the most important for the end-users, they must allow the user to understand
what went wrong with the code they wrote. The error messages should be as explicit as possible, pointing out
what is the reason why the error (and maybe in the future, providing some suggestions to fix the problems).

## Consistency Errors

Consistency errors are meant to be used internally within our team to diagnose what went wrong with Viper's code
generation. As said previously, if they were to happen in production, we should provide a way for the user to create
an automatic report for us.

## Verification Errors

Verification errors are essential for end-users, they should be able to understand what is wrong with the code 
and then fix it. At the moment of writing of this document, we are focusing on:

1. Kotlin Contracts: conditional effects and calls in place.
2. List access functions: possible out-of-bound errors at runtime.

### Generated Errors

This section analyzes the errors generated by Viper during the verification process. The complete lists of generated 
errors can be found [here](https://github.com/viperproject/silver/blob/07dce2bf8a90f6be9443ece6d1697b0e2767fb48/src/main/scala/viper/silver/verifier/VerificationError.scala).

Currently, our test suite for bad contracts considerate the following Kotlin errors:

*   Type casting errors (`as_type_contract.kt`)
*   Accessing list with out of bound indices (`binary_search.kt`, `list.kt`)
*   Violated calls in place contract (`calls_in_place.kt`)
    *   Leaked function from calls in place contract (`calls_in_place_leak.kt`, `inlining_captured.kt`)
*   Incorrect returned values (`returns_booleans.kt`)
*   Conditional effects violation (`returns_null.kt`)
    *   Implying types (`is_type_contract.kt`)

From this test suite we get three main verification errors by Viper:

1. `PostconditionViolated`: a post-condition on a method's contract is violated.
2. `PreconditionInCallFalse`: a pre-condition fails when invoking a Viper's method.
3. `AssertFailed` (the only case is `calls_in_place_leak.kt`): an assertion statement might not hold.

Our goal is mapping Viper's errors into Kotlin's ones, providing valuable information to the end-users.

Each one of these errors brings with them some information, illustrated in the table below.

| Error Kind                	| Reason         	| Offending Node        	| Member 	| Context                                	|
|---------------------------	|----------------	|-----------------------	|--------	|----------------------------------------	|
| `PostconditionViolated`   	| `AssertionFalse` 	| Postcondition         	| Method 	| Conditional Effect, Calls in Place     	|
| `PreconditionInCallFalse` 	| `AssertionFalse` 	| Call-site of a method 	| /      	| Leaking Calls in Place, List Functions 	|
| `AssertFailed`            	| `AssertionFalse` 	| Assert Statement      	| /      	| Leaking Calls in Place                 	|

The output errors are not human friendly at all, bringing generic error messages to the end-user:
```
/as_type_contract.kt:(194,236): warning: Viper verification error: Postcondition of global$fun_getX$fun_take$T_Any$return$NT_Int might not hold. Assertion ret != (dom$Nullable$null(): dom$Nullable[Int]) ==> !dom$Type$isSubtype((dom$TypeOf$typeOf(local$a): dom$Type), dom$Type$global$class_IntHolder()) might not hold.
```

The example above taken from `as_type_contract.kt` informs us a *post-condition* might not be hold, but it does not 
tell us they why, nor what was the original purpose of this error.

### Digging into Verification Errors

Each error generated by Viper brings three main information:

1.  The kind of error: this is obtained by the error instance's type at runtime.
2.  The reason: why the error was generated. This information, mainly of type `AssertionFalse`, has two main fields: an 
    identifier and the `offendingNode` (who caused the error). The list of reasons can be found [here](https://github.com/viperproject/silver/blob/ce5523d0c902f5ff61c8af49f80cd180f758c5b5/src/main/scala/viper/silver/verifier/VerificationError.scala#L591).
3.  The offending node: where the error generated from the verification process. Notice that this information may be
    different from the one embedded into reason.

TODO: understand how to use this information to translate the Viper errors for end-users.

TODO: the next step would be on how to map these errors back to Kotlin.